<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Tells you whether a decrypted TLS payload is an LLM API call, an MCP message, or just normal HTTP — in microseconds, from a single buffer, with no connection state."><title>busted_classifier - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-b7b9f40b.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="busted_classifier" data-themes="" data-resource-suffix="" data-rustdoc-version="1.95.0-nightly (6efa357bf 2026-02-08)" data-channel="nightly" data-search-js="search-fb33671b.js" data-stringdex-js="stringdex-b897f86f.js" data-settings-js="settings-170eb4bf.js" ><script src="../static.files/storage-f9617a14.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-12f88f4f.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-f7c3ffd8.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc mod crate"><a class="skip-main-content" href="#main-content">Skip to main content</a><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">Crate busted_classifier</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../busted_classifier/index.html">busted_<wbr>classifier</a><span class="version">0.1.0</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#the-problem" title="The problem">The problem</a></li><li><a href="#how-it-works" title="How it works">How it works</a></li><li><a href="#architecture" title="Architecture">Architecture</a></li><li><a href="#integration-with-busted" title="Integration with Busted">Integration with Busted</a></li><li><a href="#usage" title="Usage">Usage</a></li><li><a href="#feature-flags" title="Feature Flags">Feature Flags</a></li></ul><h3><a href="#reexports">Crate Items</a></h3><ul class="block"><li><a href="#reexports" title="Re-exports">Re-exports</a></li><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#functions" title="Functions">Functions</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content" tabindex="-1"><div class="main-heading"><h1>Crate <span>busted_<wbr>classifier</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/busted_classifier/lib.rs.html#1-703">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Tells you whether a decrypted TLS payload is an LLM API call, an MCP message, or
just normal HTTP — in microseconds, from a single buffer, with no connection state.</p>
<h2 id="the-problem"><a class="doc-anchor" href="#the-problem">§</a>The problem</h2>
<p>Every major LLM provider (OpenAI, Anthropic, Google, AWS Bedrock, Cohere, Mistral,
Groq, and more) serves its API over HTTPS. To a traditional network monitor, a
<code>POST /v1/chat/completions</code> to <code>api.openai.com</code> looks identical to any other TLS
connection — just encrypted bytes on port 443. Even after you’ve intercepted the
plaintext (via eBPF uprobes on <code>SSL_write</code>/<code>SSL_read</code>), you’re left with a raw byte
buffer. Is it a GPT-4 request? A Claude conversation? An MCP tool invocation? Or
someone browsing Reddit? This crate answers that question.</p>
<p><code>busted-classifier</code> encodes deep knowledge of LLM API shapes, MCP’s JSON-RPC 2.0
protocol, SDK user-agent strings, and streaming response formats into a fast,
stateless classification pipeline. Hand it a <code>&amp;[u8]</code> and a direction, and it tells
you exactly what you’re looking at.</p>
<h2 id="how-it-works"><a class="doc-anchor" href="#how-it-works">§</a>How it works</h2>
<p>Classification flows through four layers, each adding detail:</p>
<p>First, we figure out if the payload is even HTTP. The <a href="http/index.html" title="mod busted_classifier::http"><code>http</code></a> module uses [<code>nom</code>]
combinators to parse HTTP/1.1 request and response headers, detect HTTP/2 binary
framing, and identify Server-Sent Events streams. If we can’t parse it as HTTP, we
still try — the payload might be a raw JSON body without framing.</p>
<p>Next, we check whether the HTTP endpoint matches a known LLM provider. The <a href="llm/index.html" title="mod busted_classifier::llm"><code>llm</code></a>
module maintains a registry of API paths and host patterns — <code>/v1/chat/completions</code>
on <code>api.openai.com</code>, <code>/v1/messages</code> on <code>api.anthropic.com</code>, and dozens more. It also
inspects JSON response bodies for telltale fields like <code>choices</code>, <code>model</code>, and
<code>completion</code>. The <a href="mcp/index.html" title="mod busted_classifier::mcp"><code>mcp</code></a> module separately detects MCP JSON-RPC 2.0 methods
(<code>tools/call</code>, <code>resources/read</code>, etc.) and categorizes them.</p>
<p>Then we fingerprint the SDK. The <a href="fingerprint/index.html" title="mod busted_classifier::fingerprint"><code>fingerprint</code></a> module extracts the <code>User-Agent</code>
header (<code>openai-python/1.12.0</code>, <code>anthropic-typescript/0.19.0</code>), pulls model
parameters from the JSON body, and computes a behavioral signature hash that can
identify the same agent across requests.</p>
<p>Finally, if the <code>pii</code> feature is enabled, the <a href="pii/index.html" title="mod busted_classifier::pii"><code>pii</code></a> module scans the payload for
leaked personally identifiable information — email addresses, credit card numbers,
SSNs, phone numbers, and API keys — so you know when sensitive data is being sent
to an LLM.</p>
<h2 id="architecture"><a class="doc-anchor" href="#architecture">§</a>Architecture</h2>
<p>The four layers map to these modules:</p>
<ol>
<li><strong>Protocol detection</strong> — HTTP/1.1 parsing (via [<code>nom</code>]), HTTP/2 binary framing,
SSE stream identification.</li>
<li><strong>Content classification</strong> — LLM API endpoint matching, MCP JSON-RPC detection.</li>
<li><strong>Agent fingerprinting</strong> — SDK extraction, model params, behavioral signature.</li>
<li><strong>PII detection</strong> — Regex scanning for sensitive data patterns.</li>
</ol>
<h2 id="integration-with-busted"><a class="doc-anchor" href="#integration-with-busted">§</a>Integration with Busted</h2>
<p>In the Busted pipeline, <code>busted-agent</code> captures decrypted TLS payloads via eBPF
uprobes, then calls <a href="fn.classify.html" title="fn busted_classifier::classify"><code>classify()</code></a> on the first chunk of each connection. The
resulting <a href="struct.Classification.html" title="struct busted_classifier::Classification"><code>Classification</code></a> is folded into a
<code>ProcessedEvent</code> and forwarded to the UI
and SIEM sinks. The crate has no dependency on eBPF or aya — it’s a pure Rust
library that works anywhere you have bytes to classify.</p>
<h2 id="usage"><a class="doc-anchor" href="#usage">§</a>Usage</h2>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>busted_classifier::{classify, Direction};

<span class="kw">let </span>payload = <span class="string">b"POST /v1/chat/completions HTTP/1.1\r\n\
    Host: api.openai.com\r\n\
    Content-Type: application/json\r\n\r\n\
    {\"model\":\"gpt-4\",\"messages\":[]}"</span>;

<span class="kw">let </span>result = classify(payload, Direction::Write, <span class="prelude-val">None</span>);
<span class="macro">assert!</span>(result.is_interesting);
<span class="macro">assert_eq!</span>(result.provider(), <span class="prelude-val">Some</span>(<span class="string">"OpenAI"</span>));
<span class="macro">assert_eq!</span>(result.model(), <span class="prelude-val">Some</span>(<span class="string">"gpt-4"</span>));</code></pre></div><h2 id="feature-flags"><a class="doc-anchor" href="#feature-flags">§</a>Feature Flags</h2>
<ul>
<li><strong><code>pii</code></strong> — Enables PII detection via regex scanning (adds <code>regex</code> dependency).
When disabled, <a href="pii/struct.PiiFlags.html" title="struct busted_classifier::pii::PiiFlags"><code>PiiFlags</code></a> fields are always <code>false</code>.</li>
</ul>
</div></details><h2 id="reexports" class="section-header">Re-exports<a href="#reexports" class="anchor">§</a></h2><dl class="item-table reexports"><dt id="reexport.ModelParams"><code>pub use fingerprint::<a class="struct" href="fingerprint/struct.ModelParams.html" title="struct busted_classifier::fingerprint::ModelParams">ModelParams</a>;</code></dt><dt id="reexport.SdkInfo"><code>pub use fingerprint::<a class="struct" href="fingerprint/struct.SdkInfo.html" title="struct busted_classifier::fingerprint::SdkInfo">SdkInfo</a>;</code></dt><dt id="reexport.McpCategory"><code>pub use mcp::<a class="enum" href="mcp/enum.McpCategory.html" title="enum busted_classifier::mcp::McpCategory">McpCategory</a>;</code></dt><dt id="reexport.McpMsgType"><code>pub use mcp::<a class="enum" href="mcp/enum.McpMsgType.html" title="enum busted_classifier::mcp::McpMsgType">McpMsgType</a>;</code></dt></dl><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><dl class="item-table"><dt><a class="mod" href="fingerprint/index.html" title="mod busted_classifier::fingerprint">fingerprint</a></dt><dd>Agent/SDK fingerprinting from User-Agent headers and request structure.</dd><dt><a class="mod" href="http/index.html" title="mod busted_classifier::http">http</a></dt><dd>HTTP/1.1 request and response parsing via [<code>nom</code>].</dd><dt><a class="mod" href="json/index.html" title="mod busted_classifier::json">json</a></dt><dd>Streaming JSON field extraction (handles truncated payloads).</dd><dt><a class="mod" href="llm/index.html" title="mod busted_classifier::llm">llm</a></dt><dd>LLM API endpoint matching for known providers.</dd><dt><a class="mod" href="mcp/index.html" title="mod busted_classifier::mcp">mcp</a></dt><dd>MCP (Model Context Protocol) JSON-RPC 2.0 detection.</dd><dt><a class="mod" href="pii/index.html" title="mod busted_classifier::pii">pii</a></dt><dd>PII (personally identifiable information) scanning.</dd></dl><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.Classification.html" title="struct busted_classifier::Classification">Classification</a></dt><dd>Full classification result.</dd></dl><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><dl class="item-table"><dt><a class="enum" href="enum.ContentClass.html" title="enum busted_classifier::ContentClass">Content<wbr>Class</a></dt><dd>Layer 2: Content classification.</dd><dt><a class="enum" href="enum.Direction.html" title="enum busted_classifier::Direction">Direction</a></dt><dd>Direction of TLS data flow.</dd><dt><a class="enum" href="enum.Protocol.html" title="enum busted_classifier::Protocol">Protocol</a></dt><dd>Layer 1: Protocol detection result.</dd></dl><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><dl class="item-table"><dt><a class="fn" href="fn.classify.html" title="fn busted_classifier::classify">classify</a></dt><dd>Classify a decrypted TLS payload chunk.</dd></dl></section></div></main></body></html>